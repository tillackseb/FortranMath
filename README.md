# math-utils
* Set compiler and compiler options running  
    ```bash
    source fpm_config.sh
    ```
* Create FORD documentation running  
    ```bash
    ford ford_settings.sh
    ```

## Thoughts on preprocessors

### The Problem
This library aims to provide functionalities for many numerical standard data types. They should all 
be accessible to the users of the library by a common interface. This, often times, requires the implementation 
of the same algorithm for many different data types. To avoid excessive code dublication and keep code 
maintanance managable, templating and some form of automtatic code generation is desired. I.e., some 
of preprocessors is needed.  
We expect the following from a preprocessing framework:
1.  It should not add any dependencies for the **users** of the library. Therefore, *preprocessing* and 
    *building* should be separated. The need to install additional software should be limited as much 
    as possible. The library should be shipped with all necessary source code in standard conform Fortran 
    beeing ready to be compiled.
2.  Code repetition should be minimal. This reduces the work for **developers** and makes the code easier 
    to maintain. Therefore, templating is desired and a preprocessor should generate standard conform 
    Fortran code for different data types from a single template. Changes to common type agnostic algorithms 
    must be applied at a single place only.
3.  The templating process should not disturb the use of **IDE capabilities** such as auto completion 
    and jumping. Therefore, public variables and procedure interfaces should be avaiable in standard 
    conform Fortran without preprocessing.

### Attempted Solution
Based on the above considerations, we decided to use the python based Fortran preprocessor *fypp* and
the following workflow:
1.  Create the file `my_module.f90` which implements a module `my_module`. This module should implement
    minimal procedures providing the interfaces for different data types. These procedures only invoke
    the main algorithm which is implemented elsewhere and imported using, e.g. `use my_module_templates`.
    This enables IDEs and other development tools to know the required interfaces at the cost of a small
    amount of code repetition.  
    An example for `my_module.f90` might look like
      ```fortran
      module my_module
        use, intrinsic :: iso_fortran_env, only : real32
        implicit none
        private

        public my_procedure

        interface my_procedure
          module procedure my_procedure_integer, my_procedure_real32
        end interface my_procedure

      contains

          subroutine my_procedure_integer( a, b )
            use my_module_templates, only : my_algorithm_integer
            integer, intent(in) :: a
            integer, intent(out) :: b
            call my_algorithm_integer( a, b )
          end subroutine my_procedure_integer
         
          subroutine my_procedure_real32( a, b )
            use my_module_templates, only : my_algorithm_real32
            real(kind=real32), intent(in) :: a
            real(kind=real32), intent(out) :: b
            call my_algorithm_real32( a, b )
          end subroutine my_procedure_real32
        
      end module my_module
      ```
2.  The implementation of the main algorithm is deferred to the file `my_module.f90.fpp`. The extension
    `.fpp` states that this file contains *fypp* syntax and has to be preprocessed. The preprocessor
    will generate standard conform Fortran code from this file.  
    An example for `my_module.f90.fpp` might look like
      ```fortran
      #: set TYPES = ['integer', 'real(kind=real32)']
      #: set NAMES = ['integer', 'real32']
      module my_module_templates
          use, intrinisic :: iso_fortran_env, only : real32
          implicit none
          private
        
      #: for NAME in NAMES
          public :: my_algorithm_${NAME}$
      #: endfor
  
      contains
  
      #: for NAME, TYPE in list( zip( NAMES, TYPES ) )
        subroutine my_algorithm_${NAME}$( a, b )
          ${TYPE}$, intent(in) :: a
          ${TYPE}$, intent(out) :: b
          ! implement type and kind agnostic algorithm here, e.g.
          b = 2 * a
        end subroutine my_algorithm_${NAME}$
      #: endfor
  
      end module my_module_templates
      ```
3.  The way the preprocessing and build process is organized adds the following requirements:  
    * Standard Fortran files (`*.f90`) and *fypp* files (`*.f90.fpp`) must be in the
      same directory.
    * The preprocessors takes *fypp* files and generates standard Fortran files in the same directory.
      The suffix `_fypp` will be added to the file name. E.g., `my_module.f90.fpp` will be translated
      into `my_module_fypp.f90`.
    * The `*_fypp.f90` files generated by the preprocessor will include a header comment telling other
      developers that this file has been created automatically and is not to be changed manually. It
      also tells the name of the original *fypp* file `*.f90.fpp` it was created from and where changes
      have to be implemented. The header also contains the time the file has been preprocessed based 
      on which the preprocessing script judges if new preprocessing of this file is necessary.
